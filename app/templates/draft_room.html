{% extends "base_arena.html" %}

{% block title %}Draft Room - {{ room.name }}{% endblock %}

{% block extra_css %}
<style>
#draft-deck-builder-panel #deck-columns {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
    align-items: flex-start;
}
#draft-deck-builder-panel .deck-columns-panel {
    padding: 0;
}
#draft-deck-builder-panel .deck-column {
    max-width: 240px;
    margin: 0 auto;
    padding-top: 0.75rem;
    position: relative;
}
#draft-deck-builder-panel .deck-column-header {
    padding: 0 1rem 0.5rem;
}
#draft-deck-builder-panel .deck-column-stack {
    display: flex;
    flex-direction: column;
    padding: 0.75rem 1rem 2rem;
}
#draft-deck-builder-panel .deck-column-stack .deck-card-entry {
    margin-top: -8rem;
    transition: transform 0.2s ease, filter 0.2s ease, margin-top 0.2s ease;
    position: relative;
}
#draft-deck-builder-panel .deck-column-stack .deck-card-entry:first-child {
    margin-top: 0;
    padding-top: 0;
}
#draft-deck-builder-panel .deck-column-stack .deck-card-entry:hover {
    transform: translateY(-4px);
    filter: brightness(1.05);
}
#draft-deck-builder-panel .deck-column-stack .deck-card-entry:hover + .deck-card-entry {
    margin-top: 0;
}
#draft-deck-builder-panel .deck-card-entry img {
    pointer-events: none;
}
#draft-deck-builder-panel .deck-card-entry .card-visual {
    box-shadow:
        0 14px 36px rgba(0, 0, 0, 0.55),
        0 6px 20px rgba(0, 0, 0, 0.4);
    border: none;
    outline: none;
    border-radius: 0.5rem;
    background: rgba(5, 7, 13, 0.65);
}
#draft-deck-builder-panel .deck-card-entry .card-visual:hover {
    box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.7),
        0 10px 28px rgba(0, 0, 0, 0.55);
}
#draft-deck-builder-panel .deck-card-entry-controls {
    display: none;
}
#draft-deck-builder-panel .deck-card-entry {
    cursor: grab;
}
</style>
{% endblock %}

{% block content %}
<div class="py-12 px-4">
    <div class="max-w-7xl mx-auto">
        <div class="text-center mb-8">
            <h1 class="font-magic text-4xl font-bold text-arena-accent">{{ room.name }}</h1>
            <p class="text-xl text-arena-text-dim">Drafting: {{ room.set_name }}</p>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
            <!-- Player List -->
            <div class="lg:col-span-1 arena-card p-4 rounded-lg">
                <h2 class="font-magic text-2xl text-arena-accent mb-4">Players</h2>
                <div id="player-list" class="space-y-2">
                    {% for player in room.players %}
                    <div id="player-{{ player.id }}" class="p-2 bg-arena-surface rounded">
                        {{ player.name }} {% if player.is_bot %}(Bot){% endif %}
                    </div>
                    {% endfor %}
                </div>
                <div class="mt-4 space-y-2">
                    <button id="add-bot-button" class="arena-button w-full py-4 px-8 rounded-lg">Add Bot</button>
                    <button id="fill-bots-button" class="arena-button w-full py-4 px-8 rounded-lg">Fill with Bots</button>
                    <button id="start-draft-button" class="arena-button w-full py-4 px-8 rounded-lg">Start Draft</button>
                    <button id="confirm-pick-button" class="arena-button w-full py-4 px-8 rounded-lg" disabled>Confirm Pick</button>
                    <div id="export-container" class="mt-4 hidden space-y-3">
                        <div class="flex flex-col gap-2">
                            <button onclick="exportDecklist(event)" class="arena-button w-full py-4 px-8 rounded-lg">Copy Decklist</button>
                            <button onclick="importDraftToDeckManager(event)" class="arena-button w-full py-4 px-8 rounded-lg bg-arena-surface">Open Deck Builder</button>
                        </div>
                        <p id="draft-export-status" class="hidden text-center text-sm text-arena-text-dim"></p>
                    </div>
                </div>
            </div>

            <!-- Main Draft Area -->
            <div class="lg:col-span-3">
                <div id="draft-complete-message" class="hidden text-center p-4 rounded-lg mb-4 arena-card">
                    <h2 class="text-2xl font-bold text-arena-accent">Draft Complete!</h2>
                    <p class="text-arena-text-dim">You can now export your decklist.</p>
                </div>
                <!-- Current Pack -->
                <div id="current-pack-container" class="arena-card p-4 mb-8 rounded-lg">
                    <h2 id="pack-header" class="font-magic text-2xl text-arena-accent mb-4">Current Pack (Pack {{ room.current_pack_number }}, Pick {{ room.current_pick_number }})</h2>
                    <div id="current-pack" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
                        <!-- Cards in the current pack will be rendered here -->
                    </div>
                </div>

                <!-- Draft Deck Builder -->
                <section id="draft-deck-builder-panel" class="arena-card p-6 rounded-lg space-y-6">
                    <div class="flex flex-wrap justify-between items-start gap-4">
                        <div>
                            <h2 class="font-magic text-2xl text-arena-accent">Draft Deck Builder</h2>
                            <p class="text-sm text-arena-text-dim">Each pick is added automatically. Drag cards between columns while everything auto-saves to your Deck Manager.</p>
                        </div>
                        <a id="draft-open-deck-builder" href="/decks/builder" class="arena-button px-5 py-2 rounded-lg font-semibold text-sm whitespace-nowrap">
                            Open Full Deck Builder
                        </a>
                    </div>
                    <div class="grid md:grid-cols-2 gap-4">
                        <div>
                            <label for="deck-name-input" class="block text-sm font-semibold text-arena-muted uppercase tracking-wide mb-2">
                                Deck name
                            </label>
                            <input
                                type="text"
                                id="deck-name-input"
                                placeholder="Draft deck"
                                class="w-full px-4 py-3 bg-arena-surface border border-arena-accent/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-arena-accent/30"
                            >
                        </div>
                        <div>
                            <label for="deck-format-select" class="block text-sm font-semibold text-arena-muted uppercase tracking-wide mb-2">
                                Format
                            </label>
                            <select
                                id="deck-format-select"
                                class="w-full px-4 py-3 bg-arena-surface border border-arena-accent/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-arena-accent/30"
                            >
                                <option value="standard">Standard</option>
                                <option value="modern">Modern</option>
                                <option value="pioneer">Pioneer</option>
                                <option value="pauper">Pauper</option>
                                <option value="legacy">Legacy</option>
                                <option value="vintage">Vintage</option>
                                <option value="duel_commander">Duel Commander</option>
                                <option value="commander_multi">Commander Multi</option>
                            </select>
                        </div>
                    </div>
                    <div class="grid md:grid-cols-3 gap-4 text-center">
                        <div class="p-4 bg-arena-surface rounded-lg border border-arena-accent/10">
                            <p class="text-sm uppercase tracking-wide text-arena-muted">Main deck</p>
                            <p id="deck-main-count" class="text-3xl font-bold text-arena-accent mt-1">0</p>
                        </div>
                        <div class="p-4 bg-arena-surface rounded-lg border border-arena-accent/10">
                            <p class="text-sm uppercase tracking-wide text-arena-muted">Sideboard</p>
                            <p id="deck-sideboard-count" class="text-3xl font-bold text-arena-text mt-1">0</p>
                        </div>
                        <div class="p-4 bg-arena-surface rounded-lg border border-arena-accent/10">
                            <p class="text-sm uppercase tracking-wide text-arena-muted">Colors</p>
                            <div id="deck-color-chips" class="flex flex-wrap justify-center gap-2 mt-2 text-sm"></div>
                        </div>
                    </div>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div>
                            <p class="text-sm font-semibold text-arena-muted uppercase tracking-wide mb-2">Type counts</p>
                            <div id="deck-type-breakdown" class="flex flex-wrap gap-2"></div>
                        </div>
                        <div>
                            <p class="text-sm font-semibold text-arena-muted uppercase tracking-wide mb-2">Mana curve</p>
                            <div class="h-40 flex items-end gap-2" id="deck-mana-curve-bars"></div>
                            <div class="flex justify-between text-xs text-arena-muted mt-2" id="deck-mana-curve-labels"></div>
                        </div>
                    </div>
                    <div class="deck-columns-panel pb-2 space-y-4">
                        <div id="deck-columns"></div>
                    </div>
                </section>
            </div>
        </div>

        <!-- All Drafted Cards -->
        <div id="all-drafted-cards" class="hidden mt-8">
            <h2 class="font-magic text-3xl text-arena-accent mb-4 text-center">Draft Complete!</h2>
            <!-- Drafted cards for all players will be rendered here -->
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', path='js/game-utils.js') }}"></script>
<script src="{{ url_for('static', path='js/game-cards.js') }}"></script>
<script src="{{ url_for('static', path='js/card-search.js') }}"></script>
<script src="{{ url_for('static', path='js/deck-library.js') }}"></script>
<script>
    (function() {
        const roomMeta = {
            id: {{ room.id|tojson }},
            name: {{ room.name|tojson }},
            set: {{ room.set_name|tojson }}
        };
        const params = new URLSearchParams(window.location.search);
        const playerParamRaw = params.get('player') || 'local';
        const sanitizedPlayer = (playerParamRaw || 'local').replace(/[^a-zA-Z0-9_-]/g, '');
        const deckId = `draft_${roomMeta.id}_${sanitizedPlayer || 'player'}`;
        window.MANAFORGE_DECK_CONTEXT = {
            deckId,
            deckName: `${roomMeta.set || 'Draft'} - ${roomMeta.name || 'Deck'}`,
            format: 'standard',
            persistEmpty: true,
            suppressUrlUpdates: true
        };
        window.MANAFORGE_DRAFT_META = {
            roomId: roomMeta.id,
            roomName: roomMeta.name,
            setName: roomMeta.set,
            deckId,
            playerParam: playerParamRaw
        };
    })();
</script>
<script src="{{ url_for('static', path='js/deck-manager.js') }}"></script>
<script>
    const roomId = "{{ room.id }}";
    const urlParams = new URLSearchParams(window.location.search);
    const playerId = urlParams.get('player') || (window.MANAFORGE_DRAFT_META ? window.MANAFORGE_DRAFT_META.playerParam : null);
    let websocket;
    const DECK_MANAGER_IMPORT_KEY = 'manaforge:deck-manager:pending-import';
    let cachedDraftedCards = [];
    let currentRoomMeta = { setName: ({{ room.set_name|tojson }} || ''), roomName: ({{ room.name|tojson }} || '') };
    const playerListElement = document.getElementById('player-list');
    const deckManagerContext = window.MANAFORGE_DECK_CONTEXT || null;
    const deckManagerLink = document.getElementById('draft-open-deck-builder');
    const deckSyncState = {
        latestCards: [],
        ready: false
    };

    if (deckManagerLink && deckManagerContext && deckManagerContext.deckId) {
        deckManagerLink.href = `/decks/builder?deckId=${encodeURIComponent(deckManagerContext.deckId)}`;
    }

    window.addEventListener('manaforge:deck-manager-ready', (event) => {
        deckSyncState.ready = true;
        const detail = event && event.detail ? event.detail : {};
        const resolvedDeckId = detail.deckId || (deckManagerContext && deckManagerContext.deckId);
        if (deckManagerLink && resolvedDeckId) {
            deckManagerLink.href = `/decks/builder?deckId=${encodeURIComponent(resolvedDeckId)}`;
        }
        syncDeckBuilderWithDraft(deckSyncState.latestCards);
    });

    function escapeAttr(value) {
        if (value === null || value === undefined) {
            return '';
        }
        return String(value)
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }

    function buildCardPreviewAttributes(card) {
        const safeCard = card || {};
        const uniqueId = safeCard.unique_id || safeCard.id || safeCard.card_id || safeCard.collector_number || safeCard.name || '';
        const fallbackId = safeCard.id || safeCard.card_id || safeCard.collector_number || uniqueId;
        const serializedCard = JSON.stringify(safeCard);
        return {
            uniqueId,
            uniqueIdAttr: escapeAttr(uniqueId),
            cardIdAttr: escapeAttr(fallbackId),
            cardNameAttr: escapeAttr(safeCard.name || ''),
            cardImageAttr: escapeAttr(safeCard.image_url || ''),
            cardDataAttr: escapeAttr(serializedCard)
        };
    }

    function initializeWebSocket() {
        if (!playerId) {
            alert("Player ID not found. Returning to lobby.");
            window.location.href = '/draft';
            return;
        }

        const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        websocket = new WebSocket(`${wsProtocol}://${window.location.host}/ws/game/${roomId}?player=${playerId}`);

        websocket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'draft_starting') {
                const packContainer = document.getElementById('current-pack');
                packContainer.innerHTML = `<div class="col-span-full text-center text-arena-text-dim p-8">Starting Draft...</div>`;
                const packHeader = document.getElementById('pack-header');
                packHeader.innerText = 'Starting Draft...';

                const addBotButton = document.getElementById('add-bot-button');
                const fillBotsButton = document.getElementById('fill-bots-button');
                const startDraftButton = document.getElementById('start-draft-button');

                addBotButton.disabled = true;
                addBotButton.classList.add('opacity-50', 'cursor-not-allowed');

                fillBotsButton.disabled = true;
                fillBotsButton.classList.add('opacity-50', 'cursor-not-allowed');
                
                startDraftButton.disabled = true;
                startDraftButton.classList.add('opacity-50', 'cursor-not-allowed');

                const loadingIndicator = document.querySelector('.fixed.inset-0');
                if (loadingIndicator) {
                    loadingIndicator.remove();
                }
            } else if (data.type === 'draft_state_update') {
                const room = data.room_state;
                currentRoomMeta = {
                    setName: room.set_name || currentRoomMeta.setName,
                    roomName: room.name || currentRoomMeta.roomName
                };
                const me = room.players.find(p => p.id === playerId);
                const packContainer = document.getElementById('current-pack');

                if (me) {
                    if (me.has_picked_card) {
                        packContainer.innerHTML = `<div class="col-span-full text-center text-arena-text-dim p-8">Waiting for other players to pick...</div>`;
                        packContainer.classList.add('opacity-50', 'pointer-events-none');
                        document.getElementById('confirm-pick-button').disabled = true;
                    } else {
                        packContainer.classList.remove('opacity-50', 'pointer-events-none');
                        if (room.state.toLowerCase() === 'drafting' && me.current_pack.length === 0) {
                             packContainer.innerHTML = `<div class="col-span-full text-center text-arena-text-dim p-8">Waiting for next pack...</div>`;
                        } else {
                            renderPack(me.current_pack);
                        }
                    }
                    renderDraftedCards(me.drafted_cards);
                }
                renderPlayerList(room);

                const packHeader = document.getElementById('pack-header');
                packHeader.innerText = `Current Pack (Pack ${room.current_pack_number}, Pick ${room.current_pick_number})`;

                if (room.state.toLowerCase() === 'drafting') {
                    const loadingIndicator = document.querySelector('.fixed.inset-0');
                    if (loadingIndicator) {
                        loadingIndicator.remove();
                    }
                    const startButton = document.getElementById('start-draft-button');
                    startButton.style.display = 'none';
                    const addBotButton = document.getElementById('add-bot-button');
                    addBotButton.style.display = 'none';
                    const fillBotsButton = document.getElementById('fill-bots-button');
                    fillBotsButton.style.display = 'none';
                    const confirmPickButton = document.getElementById('confirm-pick-button');
                    confirmPickButton.style.display = 'block';
                } else if (room.state.toLowerCase() === 'completed') {
                    // Hide drafting elements and show completion message
                    document.getElementById('current-pack-container').style.display = 'none';
                    document.getElementById('confirm-pick-button').style.display = 'none';
                    document.getElementById('draft-complete-message').classList.remove('hidden');
                    document.getElementById('export-container').classList.remove('hidden');

                    const allDraftedCardsContainer = document.getElementById('all-drafted-cards');
                    allDraftedCardsContainer.classList.remove('hidden');
                    
                    let content = '';
                    for (const player of room.players) {
                        content += `<div class="mb-8 arena-card p-4">`;
                        content += `<div class="flex justify-between items-center mb-4">`;
                        content += `<h3 class="font-magic text-2xl text-arena-accent">${player.name}'s Drafted Cards</h3>`;
                        content += `</div>`;
                        content += `<div class="grid grid-cols-3 md:grid-cols-5 lg:grid-cols-8 gap-4">`;
                        content += player.drafted_cards.map(card => {
                            const attrs = buildCardPreviewAttributes(card);
                            return `
                            <div class="draft-card"
                                data-card-id="${attrs.cardIdAttr}"
                                data-card-name="${attrs.cardNameAttr}"
                                data-card-image="${attrs.cardImageAttr}"
                                data-card-data="${attrs.cardDataAttr}">
                                <img src="${attrs.cardImageAttr}" alt="${attrs.cardNameAttr}" class="rounded-lg w-full">
                            </div>
                        `;
                        }).join('');
                        content += `</div></div>`;
                    }
                    allDraftedCardsContainer.innerHTML = content;
                }
            }
        };
    }

    let selectedCardId = null;

    function renderPack(pack) {
        const packContainer = document.getElementById('current-pack');
        packContainer.innerHTML = pack.map(card => {
            const attrs = buildCardPreviewAttributes(card);
            return `
            <div id="card-${attrs.uniqueIdAttr}" class="cursor-pointer"
                data-select-id="${attrs.uniqueIdAttr}"
                data-card-id="${attrs.cardIdAttr}"
                data-card-name="${attrs.cardNameAttr}"
                data-card-image="${attrs.cardImageAttr}"
                data-card-data="${attrs.cardDataAttr}"
                onclick="selectCard(this.dataset.selectId)">
                <img src="${attrs.cardImageAttr}" alt="${attrs.cardNameAttr}" class="rounded-lg w-full">
            </div>
        `;
        }).join('');
    }

    function renderDraftedCards(cards) {
        const safeCards = Array.isArray(cards) ? cards : [];
        cachedDraftedCards = safeCards.map((card) => cloneCardData(card)).filter(Boolean);
        deckSyncState.latestCards = cachedDraftedCards.map((card) => cloneCardData(card)).filter(Boolean);
        syncDeckBuilderWithDraft(deckSyncState.latestCards);
    }

    function getPlayerNameElement(targetPlayerId) {
        if (!targetPlayerId) return null;
        const escapedId = window.CSS && window.CSS.escape ? window.CSS.escape(targetPlayerId) : targetPlayerId.replace(/"/g, '\\"');
        return document.querySelector(`[data-player-entry-name="${escapedId}"]`);
    }

    async function submitDraftNameChange(targetPlayerId, desiredName) {
        const trimmed = desiredName.trim();
        if (!trimmed) {
            throw new Error('Name cannot be empty.');
        }
        const response = await fetch(`/api/v1/draft/rooms/${encodeURIComponent(roomId)}/rename`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ player_id: targetPlayerId, player_name: trimmed })
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
            throw new Error(payload.detail || 'Unable to update name.');
        }
        return payload?.name || trimmed;
    }

    function finishDraftNameEdit(nameElement, targetPlayerId, originalName, commit = true) {
        const cleanup = () => {
            nameElement.removeAttribute('contenteditable');
            nameElement.classList.remove('ring-2', 'ring-arena-accent/50', 'px-1', 'rounded');
            nameElement.dataset.editing = 'false';
        };

        if (!commit) {
            nameElement.textContent = originalName;
            cleanup();
            return;
        }

        const nextValue = nameElement.textContent.trim();
        if (!nextValue || nextValue === originalName) {
            nameElement.textContent = originalName;
            cleanup();
            return;
        }

        submitDraftNameChange(targetPlayerId, nextValue)
            .then((sanitized) => {
                nameElement.textContent = sanitized || nextValue;
                showDraftStatus('Name updated.', 'success');
            })
            .catch((error) => {
                console.error('Unable to rename player', error);
                nameElement.textContent = originalName;
                showDraftStatus(error.message || 'Unable to update name.', 'error');
            })
            .finally(cleanup);
    }

    function startDraftNameEdit(targetPlayerId) {
        if (!playerId || playerId !== targetPlayerId) return;
        const nameElement = getPlayerNameElement(targetPlayerId);
        if (!nameElement || nameElement.dataset.editing === 'true') return;
        const originalName = nameElement.textContent.trim();
        nameElement.dataset.editing = 'true';
        nameElement.contentEditable = 'true';
        nameElement.spellcheck = false;
        nameElement.classList.add('ring-2', 'ring-arena-accent/50', 'px-1', 'rounded');
        setTimeout(() => selectTextContent(nameElement), 0);

        const handleKeydown = (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                nameElement.removeEventListener('keydown', handleKeydown);
                nameElement.removeEventListener('blur', handleBlur);
                finishDraftNameEdit(nameElement, targetPlayerId, originalName, true);
            } else if (event.key === 'Escape') {
                event.preventDefault();
                nameElement.removeEventListener('keydown', handleKeydown);
                nameElement.removeEventListener('blur', handleBlur);
                finishDraftNameEdit(nameElement, targetPlayerId, originalName, false);
            }
        };

        const handleBlur = () => {
            nameElement.removeEventListener('keydown', handleKeydown);
            nameElement.removeEventListener('blur', handleBlur);
            finishDraftNameEdit(nameElement, targetPlayerId, originalName, true);
        };

        nameElement.addEventListener('keydown', handleKeydown);
        nameElement.addEventListener('blur', handleBlur);
    }

    function selectTextContent(element) {
        if (!element) return;
        const range = document.createRange();
        range.selectNodeContents(element);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
    }

    function renderPlayerList(room) {
        if (!playerListElement) return;
        const players = Array.isArray(room.players) ? room.players : [];
        playerListElement.innerHTML = players.map((p) => {
            const safeId = escapeAttr(p.id || '');
            const safeName = escapeAttr(p.name || '');
            const statusIcon = p.has_picked_card
                ? `<span class="text-green-400" title="Card picked">&#10003;</span>`
                : '';
            const canRename = Boolean(playerId && p.id === playerId && !p.is_bot);
            const renameButton = canRename
                ? `<button type="button" class="text-xs text-arena-muted hover:text-arena-accent transition-colors" title="Rename" data-player-rename="${safeId}">✏️</button>`
                : '';
            const botLabel = p.is_bot ? `<span class="text-xs text-arena-text-dim">(Bot)</span>` : '';
            return `
                <div id="player-${safeId}" class="p-2 bg-arena-surface rounded flex items-center justify-between ${p.id === playerId ? 'font-bold' : ''}">
                    <span class="flex items-center gap-2">
                        <span data-player-entry-name="${safeId}">${safeName}</span>
                        ${botLabel}
                        ${renameButton}
                    </span>
                    ${statusIcon}
                </div>
            `;
        }).join('');
    }

    function selectCard(cardUniqueId) {
        if (selectedCardId) {
            document.getElementById(`card-${selectedCardId}`).classList.remove('ring-2', 'ring-yellow-400');
        }
        selectedCardId = cardUniqueId;
        document.getElementById(`card-${selectedCardId}`).classList.add('ring-2', 'ring-yellow-400');
        document.getElementById('confirm-pick-button').disabled = false;
    }

    function pickCard() {
        if (selectedCardId) {
            websocket.send(JSON.stringify({
                type: 'pick_card',
                card_unique_id: selectedCardId
            }));
            selectedCardId = null;
            document.getElementById('confirm-pick-button').disabled = true;
        }
    }

    function exportDecklist(event) {
        event.stopPropagation();
        if (!websocket) {
            showDraftStatus('Connection not ready. Try again in a moment.', 'error');
            return;
        }

        showDraftStatus('Preparing decklist...', 'info');
        const originalOnMessage = websocket.onmessage;
        websocket.onmessage = async (messageEvent) => {
            const data = JSON.parse(messageEvent.data);
            if (data.type === 'decklist_data') {
                try {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        await navigator.clipboard.writeText(data.decklist);
                    } else {
                        throw new Error('Clipboard API unavailable');
                    }
                    showDraftStatus('Decklist copied to clipboard.', 'success');
                } catch (error) {
                    console.error('Clipboard copy failed', error);
                    showDraftStatus('Clipboard unavailable. Downloading instead.', 'error');
                    downloadDecklistFallback(data.decklist);
                } finally {
                    websocket.onmessage = originalOnMessage;
                }
            } else {
                originalOnMessage(messageEvent);
            }
        };

        websocket.send(JSON.stringify({ type: 'get_decklist' }));
    }

    function downloadDecklistFallback(decklist) {
        const blob = new Blob([decklist], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'drafted-deck.txt';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function showDraftStatus(message, variant = 'info') {
        const statusEl = document.getElementById('draft-export-status');
        if (!statusEl) {
            return;
        }
        if (!message) {
            statusEl.textContent = '';
            statusEl.classList.add('hidden');
            return;
        }
        statusEl.textContent = message;
        statusEl.classList.remove('hidden', 'text-red-400', 'text-arena-accent', 'text-arena-text-dim');
        if (variant === 'success') {
            statusEl.classList.add('text-arena-accent');
        } else if (variant === 'error') {
            statusEl.classList.add('text-red-400');
        } else {
            statusEl.classList.add('text-arena-text-dim');
        }
    }

    function cloneCardData(card) {
        if (!card) {
            return null;
        }
        try {
            return JSON.parse(JSON.stringify(card));
        } catch (error) {
            console.warn('Unable to clone card data', error);
            return card;
        }
    }

    function getCardIdentity(card) {
        if (!card) {
            return null;
        }
        return card.id || card.card_id || card.scryfall_id || card.unique_id || (card.set && card.collector_number ? `${card.set}-${card.collector_number}` : card.name) || null;
    }

    function buildDraftCardCounts(cards) {
        const counts = {};
        const samples = {};
        cards.forEach((card) => {
            const key = getCardIdentity(card);
            if (!key) {
                return;
            }
            if (!samples[key]) {
                samples[key] = card;
            }
            counts[key] = (counts[key] || 0) + 1;
        });
        return { counts, samples };
    }

    function getDeckManagerCardCounts() {
        if (!window.DeckManager || !DeckManager.state || !DeckManager.state.entries) {
            return {};
        }
        const counts = {};
        Object.values(DeckManager.state.entries).forEach((entry) => {
            if (!entry || !entry.card) return;
            const key = getCardIdentity(entry.card);
            if (!key) return;
            counts[key] = (counts[key] || 0) + (entry.quantity || 0);
        });
        return counts;
    }

    function removeDeckManagerCopies(cardKey, quantity) {
        if (!cardKey || !quantity || !window.DeckManager || !DeckManager.state || !DeckManager.state.entries) {
            return;
        }
        let remaining = quantity;
        const entryIds = Object.keys(DeckManager.state.entries);
        for (const entryId of entryIds) {
            if (remaining <= 0) {
                break;
            }
            const entry = DeckManager.state.entries[entryId];
            if (!entry || !entry.card) {
                continue;
            }
            const entryKey = getCardIdentity(entry.card);
            if (entryKey !== cardKey) {
                continue;
            }
            const currentQty = entry.quantity || 0;
            if (currentQty <= 0) {
                continue;
            }
            const nextQty = Math.max(0, currentQty - remaining);
            const removed = currentQty - nextQty;
            DeckManager.updateEntryQuantity(entryId, nextQty);
            remaining -= removed;
        }
    }

    function syncDeckBuilderWithDraft(cards) {
        if (!deckSyncState.ready || !window.DeckManager || !DeckManager.state) {
            return;
        }
        const { counts: targetCounts, samples } = buildDraftCardCounts(Array.isArray(cards) ? cards : []);
        const currentCounts = getDeckManagerCardCounts();
        const handledKeys = new Set();

        Object.entries(targetCounts).forEach(([cardKey, desiredCount]) => {
            handledKeys.add(cardKey);
            const current = currentCounts[cardKey] || 0;
            if (current < desiredCount) {
                const diff = desiredCount - current;
                const sample = samples[cardKey];
                if (sample) {
                    DeckManager.addCard(cloneCardData(sample), { quantity: diff });
                }
            } else if (current > desiredCount) {
                removeDeckManagerCopies(cardKey, current - desiredCount);
            }
        });

        Object.keys(currentCounts).forEach((cardKey) => {
            if (!handledKeys.has(cardKey)) {
                removeDeckManagerCopies(cardKey, currentCounts[cardKey]);
            }
        });
    }

    function importDraftToDeckManager(event) {
        event.stopPropagation();
        const deckIdTarget = deckManagerContext && deckManagerContext.deckId;
        if (deckIdTarget) {
            showDraftStatus('Opening deck builder...', 'info');
            window.location.href = `/decks/builder?deckId=${encodeURIComponent(deckIdTarget)}`;
            return;
        }
        if (!cachedDraftedCards.length) {
            showDraftStatus('Finish drafting before importing.', 'error');
            return;
        }
        try {
            const grouped = new Map();
            cachedDraftedCards.forEach((card) => {
                if (!card) return;
                const key = card.id || card.scryfall_id || card.unique_id || card.name;
                if (!key) return;
                if (!grouped.has(key)) {
                    grouped.set(key, { card, quantity: 0 });
                }
                grouped.get(key).quantity += 1;
            });

            if (!grouped.size) {
                showDraftStatus('No cards available to import.', 'error');
                return;
            }

            const deckPayload = {
                name: `${currentRoomMeta.setName || currentRoomMeta.roomName || 'ManaForge'} Draft Deck`,
                format: 'standard',
                cards: Array.from(grouped.values()),
                commanders: []
            };

            localStorage.setItem(DECK_MANAGER_IMPORT_KEY, JSON.stringify({
                deck: deckPayload,
                message: 'Draft deck imported from draft room.',
                source: 'draft'
            }));

            showDraftStatus('Deck sent to Deck Manager!', 'success');
            window.location.href = '/decks/builder';
        } catch (error) {
            console.error('Unable to import deck into deck manager', error);
            showDraftStatus('Import failed. Please try again.', 'error');
        }
    }

    document.getElementById('add-bot-button').addEventListener('click', () => {
        if (websocket) websocket.send(JSON.stringify({ type: 'add_bot' }));
    });
    document.getElementById('fill-bots-button').addEventListener('click', () => {
        if (websocket) websocket.send(JSON.stringify({ type: 'fill_bots' }));
    });
    document.getElementById('confirm-pick-button').addEventListener('click', pickCard);
    document.getElementById('confirm-pick-button').style.display = 'none';
    document.getElementById('start-draft-button').addEventListener('click', () => {
        if (websocket) websocket.send(JSON.stringify({ type: 'start_draft' }));
    });
    if (playerListElement) {
        playerListElement.addEventListener('click', (event) => {
            const trigger = event.target.closest('[data-player-rename]');
            if (!trigger) return;
            const targetId = trigger.dataset.playerRename;
            startDraftNameEdit(targetId);
        });
    }

    window.addEventListener('load', initializeWebSocket);

</script>
{% endblock %}
